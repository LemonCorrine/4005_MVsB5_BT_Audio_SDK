#!/usr/bin/python
# -*- coding: UTF-8 -*- 

import threading, time, subprocess, types
import os, sys, struct, re
import time
import platform
import ctypes
import configparser
import getopt
import openpyxl
from openpyxl.utils import quote_sheetname
from openpyxl.styles import Font
from openpyxl.styles import Alignment

import msvcrt


re_param_name = r"^param(\d+)_name"
re_param_type = r"^param(\d+)_type"
re_param_content = r"^param(\d+)_content"
re_param_default = r"^param(\d+)_default"

re_param_ui_type = r"^param(\d+)_ui_type"
# re_param_ui_unit_len = r"^param(\d+)_ui_unit_len"
re_param_ui_unit_content = r"^param(\d+)_ui_unit_content"
re_param_ui_fract = r"^param(\d+)_ui_fract"
re_param_ui_ratio = r"^param(\d+)_ui_ratio"
re_param_ui_tips = r"^param(\d+)_ui_tips"

re_param_ui_location = r"^param(\d+)_ui_location"
re_roboeffect_ver = r"Roboeffect_Lib_version:\s*(\d+\.\d+\.\d+)"
# re_hex_a_byte = r"(0x[0-9a-fA-F][0-9a-fA-F])|\'([\w])\'"
re_hex_a_byte = r"(0x[0-9a-fA-F][0-9a-fA-F])"

exclusions_list = []

main_version_str = '0.0.0'
total_effect_num = 0

PARAM_TYPE_BOOL = 0
PARAM_TYPE_ENUM = 1
PARAM_TYPE_VALUE = 2
PARAM_TYPE_DISPLAY = 3

splite_explaination = """
/**
* Before everything, please copy 
*
*  ROBOEFFECT_{}
*
* to the tail of roboeffect_user_effect_type_enum
**/


"""


user_defined_header = """
/**
 **************************************************************************************
 * @file    user_defined_effect_api.h
 * @brief   interface for user defined effect algorithm
 *          Automatically generated by the script, no manual modification required.
 *
 * @author  Castle Cai
 * @version V1.0.0
 *
 * &copy; Shanghai Mountain View Silicon Technology Co.,Ltd. All rights reserved.
 **************************************************************************************
 */

#include "roboeffect_api.h"
#include "roboeffect_config.h"


"""


name_list = []
macro_main = ""


class myconf(configparser.ConfigParser):
    def __init__(self,defaults=None):
        configparser.ConfigParser.__init__(self,defaults=None,allow_no_value=True)
    def optionxform(self, optionstr):
        return optionstr

def get_path():
    # determine if application is a script file or frozen exe
    if getattr(sys, 'frozen', False):
        application_path = os.path.dirname(sys.executable)
    elif __file__:
        application_path = os.path.dirname(__file__)
    return application_path

def bits_width_convert(str):
    if str == '16':
        return 0
    elif str == '24':
        return 1
    elif str == '16/24' or str == '24/16':
        return 2
    else:
        return 0

def channel_convert(str):
    if str == 'N/A':
        return 0
    elif str == 'mono':
        return 1
    elif str == 'stereo':
        return 2
    elif str == 'mono/stereo' or str == 'stereo/mono':
        return 3
    else:
        return 0

def channel_convert_2(str):
    if str == 'N/A':
        return 'NA'
    elif str == 'mono':
        return 'ROBOEFFECT_CH_MONO'
    elif str == 'stereo':
        return 'ROBOEFFECT_CH_STEREO'
    elif str == 'mono/stereo' or str == 'stereo/mono':
        return 'ROBOEFFECT_CH_MONO_STEREO'
    else:
        return 'NA'

def param_type_convert(str):
    if str == 'bool':
        return 0
    elif str == 'enum':
        return 1
    elif str == 'value':
        return 2
    elif str == 'display':
        return 3
    else:
        return 2

def ui_display_type_convert(type, str):
    if type == 'bool':
        if str == 'check_box':
            return 0
        elif str == 'push_button':
            return 1
        else:
            return 0

    elif type == 'enum':
        if str == 'comb_box':
            return 0
        else:
            return 0

    elif type == 'value':
        if str == 'spinbox':
            return 0
        elif str == 'hslider':
            return 1
        elif str == 'vsilder':
            return 2
        else:
            return 0
    elif type == 'display':
        if str == 'label':
            return 0
        elif str == 'progress_bar':
            return 1
        elif str == 'on_off':
            return 2
        else:
            return 0

def ui_layout_convert(str):
    if str == 'auto':
        return 0
    elif str == 'manual':
        return 1
    else:
        return 0

def aligned_macro_to_string(str, en):
    output = ""
    output += str + (35-len(str))*' ' + '(%d)'%(en)
    return output

def aligned_param_to_string(str):
    output = ""
    output += str + ',' + (6-len(str))*' '
    return output

def aligned_config_to_string(str):
    output = ""
    output += str + ',' + (14-len(str))*' '
    return output

def aligned_param_len_to_string(str):
    output = ""
    output += "ROBOEFFECT_" + str + '_PARAM_LEN ' + (24-len(str))*' '
    return output


method_map = {
    'METHOD_NONE' : 0x00,
    'METHOD_INIT' : 0x01,
    'METHOD_CFG_1' : 0x02,
    'METHOD_CFG_2' : 0x04,
    'METHOD_CFG_3' : 0x08,
    'METHOD_CFG_FADEOI' : 0x10,
    'METHOD_CFG_STEP' : 0x20,
}

INTERFACE_TEMPLATE = (
"//%s interface\n"
"bool roboeffect_%s_init_if(void *node);\n"
"bool roboeffect_%s_config_if(void *node, int16_t *new_param, uint8_t param_num, uint8_t len);\n"
"bool roboeffect_%s_apply_if(void *node, int16_t *pcm_in1, int16_t *pcm_in2, int16_t *pcm_out, int32_t n);\n"
"int32_t roboeffect_%s_scratch_size(uint32_t sample_rate, uint16_t frame_size, uint16_t width, uint8_t ch_num, int16_t *parameters);\n"
)
def interface_string_gen(str):
    output = INTERFACE_TEMPLATE%(str, str, str, str, str)
    return output

def count_bytes_in_string(str):
    
    bytes_num = 0
    pattern = re.compile(re_hex_a_byte)
    for oneline in str.splitlines():
        matched = pattern.findall(oneline)
        if(matched):
            bytes_num += len(matched)
            # print("%s ---> %d"%(oneline.split('//')[0], len(matched)))
    
    return bytes_num

def save_bytes_in_string_to_bing(str, file):
    bin_f = open(file, 'wb')
    pattern = re.compile(re_hex_a_byte)
    for oneline in str.splitlines():
        matched = pattern.findall(oneline)
        # print(len(matched))
        if(matched):
            for index, byte_str in enumerate(matched, 0):
                # print(matched[page_num])
                bin_f.write(struct.pack('B', int(byte_str, base=16)))
    bin_f.close()

def del_last_ch(str, ch):
    index = str.rfind(ch)
    if index != -1:
        modified_string = str[:index] + str[index+1:]
    else:
        modified_string = str
    return modified_string

def do_pause(is_auto):
    if not is_auto:
        msvcrt.getch()
    else:
        pass

libs_info_str = ""
libs_info_str_sub = ""
api_info_str_2 = ""#effect_property_for_robo
engine_config_str_1 = ""#effect enable-disable macro
engine_config_str_3 = ""#effects interfaces
engine_config_str_4 = "\n//effects parameters length\n"#parameter length
output_folder = ""
robo_ver = ""

split_effect_name = ""

xls_file = "UserLibsData.xlsx"
work_folder = '.'
is_auto = False

if __name__=="__main__":
    print('user effect libs data generator by excel, ver=1.1, no parameters')

    try:
        options,args = getopt.getopt(sys.argv[1:], "hp:", ["help", "process"])
    except getopt.GetoptError as err:
        print("arg error!")
        sys.exit(1)

    for name,value in options:
        if name in ("-p","--process"):
            work_folder = value
            is_auto = True
        if name in ("-h","--help"):
            print ("\nThis is the usage function")
            print ('-p, --process: processing folder')
            sys.exit(1)

    for entry in os.listdir(work_folder):
        #first check excel file
        abs_dir = os.path.join(work_folder, entry)
        if os.path.isdir(abs_dir):
            # print(abs_dir)
            # print(os.path.abspath(entry))  # 输出子目录的绝对路径
            relative_xls_path = os.path.join(abs_dir, "UserLibsData.xlsx")
            if not os.path.isfile(relative_xls_path):
                print("found folder %s, but UserLibsData.xlsx not existed"%(entry))
                do_pause(is_auto)
                sys.exit(1)

    # sys.exit(1)

    #Do real work
    for entry in os.listdir(work_folder):
        abs_dir = os.path.join(work_folder, entry)
        if os.path.isdir(abs_dir):
            relative_xls_path = os.path.join(abs_dir, "UserLibsData.xlsx")

            # print("begin to open: %s"%(relative_xls_path))
            try:
                wb = openpyxl.load_workbook(relative_xls_path)
            except IOError:
                print(f"{xls_file} file not existed?")
                do_pause(is_auto)
                sys.exit(1)
            except Exception as e:
                print(e)
                do_pause(is_auto)
                sys.exit(1)
            
            libs_info_str = ""
            api_info_str_2 = ""
            engine_config_str_3 = ""
            
            for sheet in wb:##
                effect_name = str(sheet.title)
                split_effect_name = effect_name
                name_list.append(effect_name)

                effect_bitwidth = str(sheet['C2'].value)
                effect_version = str(sheet['B2'].value)
                effect_in1_ch = str(sheet['D2'].value)
                effect_in2_ch = str(sheet['E2'].value)
                effect_out_ch = str(sheet['F2'].value)
                effect_frame_size = str(sheet['H2'].value)
                effect_cnx_name = str(sheet['I2'].value)
                effect_ui_layout_mode = str(sheet['Q3'].value)
                effect_ui_grid_size = str(sheet['R3'].value)
                effect_param_number = 0
                effect_has_scratch = 1 if str(sheet['A3'].value) == 'scratch' else 0

                param_dict = {}
                for i, row in enumerate(sheet.iter_rows(min_row=5, values_only=True)):
                    # effect_param_number = 0 if row[1] == None and i == 0 else effect_param_number + 1
                    if row[1]:
                        unit = {'type':row[2], 'content':row[3], 'default':row[4], 'param_config':row[5], 'skip':row[6], 'ui_type':row[7], 'unit_content':row[8], 'fract':row[9], 'ratio':row[10], 'tips':row[11], 'check':row[12], 'Row':row[13], 'Column':row[14]}
                        param_dict[str(row[1])] = unit
                        effect_param_number = effect_param_number + 1
                    # print("%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s"%(row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10], row[11], row[12], row[13]))
                libs_info_str_sub = ''
                
                api_info_str_2 += ("\t{")

                engine_config_str_3 += interface_string_gen(effect_name) + '\n'

                print("item: %s, ver=%s, bitwidth=%s, number=%d"%(effect_name, effect_version, effect_bitwidth, effect_param_number))

                # effect version
                libs_info_str_sub += "0x%02X, 0x%02X, 0x%02X, \\\n"%(int(effect_version.split('.')[0]), int(effect_version.split('.')[1]), int(effect_version.split('.')[2]))
                # libs_info_str_sub += ("//" + effect_name + '@' + effect_version + '\n')

                # effect name
                libs_info_str_sub += ("0x%02X, \\\n"%(len(effect_name)))
                for c in effect_name:
                    libs_info_str_sub += ("0x%02X, "%(struct.unpack('B', bytes(c, 'utf-8'))))
                libs_info_str_sub += ('\\\n')
            
                # bitwidth
                libs_info_str_sub += ("0x%02X, \\\n"%(bits_width_convert(effect_bitwidth)))
                libs_info_str_sub += ("0x%02X, \\\n"%(channel_convert(effect_in1_ch)))
                libs_info_str_sub += ("0x%02X, \\\n"%(channel_convert(effect_in2_ch)))
                libs_info_str_sub += ("0x%02X, \\\n"%(channel_convert(effect_out_ch)))

                api_info_str_2 += "ROBOEFFECT_%s, %s, %s, %s, %s,\\\n"%(effect_name.upper(), channel_convert_2(effect_out_ch), effect_frame_size, effect_param_number, effect_cnx_name)
                # api_info_str_2 += ("#if %s\\\n"%(effect_name.upper() + '_ENABLE'))
                if effect_has_scratch:
                    api_info_str_2 += "\troboeffect_%s_init_if, roboeffect_%s_config_if, roboeffect_%s_apply_if, roboeffect_%s_scratch_size,\\\n"%(effect_name, effect_name, effect_name, effect_name)
                else:
                    api_info_str_2 += "\troboeffect_%s_init_if, roboeffect_%s_config_if, roboeffect_%s_apply_if, NULL,\\\n"%(effect_name, effect_name, effect_name)

                # api_info_str_2 += ("#else\\\n")
                # if effect_has_scratch:
                #     api_info_str_2 += "\tROBOEFFECT_EFF_IF_NAME_INIT(null), ROBOEFFECT_EFF_IF_NAME_CONF(null), ROBOEFFECT_EFF_IF_NAME_APPLY(null), ROBOEFFECT_EFF_IF_NAME_SCRATCH(null),\\\n"
                # else:
                #     api_info_str_2 += "\tROBOEFFECT_EFF_IF_NAME_INIT(null), ROBOEFFECT_EFF_IF_NAME_CONF(null), ROBOEFFECT_EFF_IF_NAME_APPLY(null), NULL,\\\n"
                
                # api_info_str_2 += ("#endif/*%s*/\n"%(effect_name.upper() + '_ENABLE'))

                default_param_str = "\t{\n"
                param_config_str = "\t{\n"

                engine_config_str_4 += ("#define " + aligned_param_len_to_string(effect_name.upper())  + str(effect_param_number) + "\n\n")
                libs_info_str_sub += ("0x%02X, \\\n"%(effect_param_number))

                param_index = 0#to show index for user
                for key, data in param_dict.items():#parameters config
                    #param name
                    libs_info_str_sub += ("0x%02X, \\\n"%(len(key), ))
                    for c in key:
                        # libs_info_str_sub += ("\'%c\', "%(c))
                        libs_info_str_sub += ("0x%02X, "%(struct.unpack('B', bytes(c, 'utf-8'))))
                    libs_info_str_sub += ('\\\n')
                    #param type
                    libs_info_str_sub += ("0x%02X, \\\n"%(param_type_convert(data['type'])))

                    #content
                    if data['content'] == None or data['type'] == 'bool':
                        pass
                    elif data['type'] == 'enum':
                        # print('enum content\n')
                        libs_info_str_sub += ("0x%02X, \\\n"%(len(data['content'])))
                        for c in data['content']:
                            # libs_info_str_sub += ("\'%c\', "%(c))
                            libs_info_str_sub += ("0x%02X, "%(struct.unpack('B', bytes(c, 'utf-8'))))
                        libs_info_str_sub += ('\\\n')
                    elif data['type'] == 'value':
                        value_check = data['content'].split(',')
                        libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(int(value_check[0])&0xFF, (int(value_check[0])>>8)&0xFF))
                        libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(int(value_check[1])&0xFF, (int(value_check[1])>>8)&0xFF))
                        libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(int(value_check[2])&0xFF, (int(value_check[2])>>8)&0xFF))
                    elif data['type'] == 'display':
                        value_check = data['content'].split(',')
                        libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(int(value_check[0])&0xFF, (int(value_check[0])>>8)&0xFF))
                        libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(int(value_check[1])&0xFF, (int(value_check[1])>>8)&0xFF))
                    
                    #default
                    libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(int(data['default'])&0xFF, (int(data['default'])>>8)&0xFF))
                    default_param_str += "\t\t%s \\\n"%(aligned_param_to_string(data['default']))

                    #param_config
                    libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(method_map[str(data['param_config'])]&0xFF, (method_map[str(data['param_config'])]>>8)&0xFF))
                    param_config_str += "\t\t%s \\\n"%(aligned_config_to_string(str(data['param_config'])))

                    if data['skip'] != '1':#for drc and eq_drc, one index has several parameters
                        param_index = param_index + 1
                        
                for key, data in param_dict.items():#UI parameters
                    if data['ui_type'] == None:
                        continue
                    libs_info_str_sub += ('0x%02X, \\\n'%(ui_display_type_convert(data['type'], data['ui_type'])))
                    if data['type'] == 'value' or data['type'] == 'display':#unit_content
                        if data['unit_content'] == None:
                            libs_info_str_sub += ("0x%02X, \\"%(0))
                        else:
                            libs_info_str_sub += ("0x%02X, \\\n"%(len(data['unit_content'])))
                            for c in data['unit_content']:
                                libs_info_str_sub += ("0x%02X, "%(struct.unpack('B', bytes(c, 'utf-8'))))
                            if data['unit_content']:
                                libs_info_str_sub += ('\\')

                        libs_info_str_sub += ('\n')

                    if data['type'] == 'value' or data['type'] == 'display':#fract
                        libs_info_str_sub += ('0x%02X, \\\n'%(int(data['fract'])))
                    if data['type'] == 'value' or data['type'] == 'display':#fract
                        libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(int(data['ratio'])&0xFF, (int(data['ratio'])>>8)&0xFF))
                    if data['type'] == 'value' or data['type'] == 'display':#tips
                        if data['tips'] is None:
                            libs_info_str_sub += ("0x%02X, \\"%(0))
                        else:
                            libs_info_str_sub += ("0x%02X, \\\n"%(len(data['tips'])))
                            for c in data['tips']:
                                libs_info_str_sub += ("0x%02X, "%(struct.unpack('B', bytes(c, 'utf-8'))))
                            if data['tips']:
                                libs_info_str_sub += ('\\')
                        libs_info_str_sub += ('\n')

                #UI layout
                if effect_ui_layout_mode == 'auto' or effect_ui_layout_mode == 'manual':#only auto or manual need layout config
                    libs_info_str_sub += ("0x%02X, \\\n"%(ui_layout_convert(effect_ui_layout_mode)))
                if effect_ui_layout_mode == 'manual':
                    grid_row = int(effect_ui_grid_size.split(',')[0])
                    grid_column = int(effect_ui_grid_size.split(',')[1])
                    libs_info_str_sub += ("0x%02X, 0x%02X, \\\n"%(grid_row, grid_column))

                    for key, data in param_dict.items():
                        grid_row = int(data['Row'])
                        grid_column = int(data['Column'])
                        libs_info_str_sub += ('0x%02X, 0x%02X, \\\n'%(grid_row, grid_column))

                default_param_str += "\t},\\\n"
                param_config_str += "\t},\\\n"

                # libs_info_str_sub += ("/*****%s end*****/\n"%(effect_name))

                # print("-------------------------begin %s-----------------------------------\n"%(effect_name))
                sub_len = count_bytes_in_string(libs_info_str_sub)
                # print("-------------------------end %s-----------------------------------\n"%(effect_name))

                # libs_info_str += ("/*****%s*****/\n"%(effect_name))
                libs_info_str += ('0x%02X, 0x%02X, \\\n'%(int(sub_len)&0xFF, (int(sub_len)>>8)&0xFF))
                libs_info_str += libs_info_str_sub

                api_info_str_2 += "\t},\n"

                break #ONLY read the first sheet

            # out_c = open(os.path.join(entry, "%s_macro.h"%(split_effect_name)), 'w+')
            # macro_main += splite_explaination.format(split_effect_name.upper())

            macro_main += "\n//Add %s_INFO_DATA to USER_DEFINED_LIBS_DATA\n"%(split_effect_name.upper())
            macro_main += "#define %s_INFO_DATA \\\n"%(split_effect_name.upper())
            libs_info_str = del_last_ch(libs_info_str, '\\')
            macro_main += libs_info_str
            # out_c.write(engine_config_str_4)

            macro_main += '\n' + engine_config_str_3

            macro_main += "\n//Add %s_INTERFACE to USER_DEFINED_INTERFACE\n"%(split_effect_name.upper())
            macro_main += "#define %s_INTERFACE \\\n"%(split_effect_name.upper())
            macro_main += api_info_str_2

            # out_c.close()

            # save_bytes_in_string_to_bing(libs_info_str, os.path.join(entry, "%s_info.bin"%(split_effect_name)))

    #write user_defined_effect_api.h
    
    out_c = open(os.path.join(work_folder, "user_defined_effect_api.h"), 'w+')
    out_c.write(user_defined_header)
    
    for name in name_list:
        out_c.write("#include \"%s.h\" \n\n"%(name))
    out_c.write("\n\n")

    out_c.write(macro_main)
    out_c.write("\n\n")

    #write USER_DEFINED_INTERFACE
    out_c.write("#define USER_DEFINED_INTERFACE")
    for name in name_list:
        out_c.write(" \\\n\t%s_INTERFACE"%(name.upper()))
    out_c.write("\n\n")


    #write USER_DEFINED_LIBS_DATA
    out_c.write("#define USER_DEFINED_LIBS_DATA")
    for name in name_list:
        out_c.write(" \\\n\t%s_INFO_DATA"%(name.upper()))
    out_c.write("\n\n")


    #write enum _roboeffect_user_effect_type_enum
    name_enum = name_list
    name_enum.append("total_max")
    out_c.write("typedef enum _roboeffect_user_effect_type_enum\n{\n")
    for index, name in enumerate(name_enum):
        if index == 0:
            out_c.write("\t/*Add user define effect ID here*/\n")
            out_c.write("\tROBOEFFECT_%s = ROBOEFFECT_USER_DEFINED_EFFECT_BEGIN,\n"%(name.upper()))
        else:
            out_c.write("\tROBOEFFECT_%s,\n"%(name.upper()))
        
    out_c.write("} roboeffect_user_effect_type_enum;\n")


    out_c.close()


    print("OK!")
    do_pause(is_auto)




